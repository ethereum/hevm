<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ds-test tutorial - hevm</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="book.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="getting-started.html">Getting Started</a></li><li class="chapter-item affix "><a href="install.html">Quick Installation</a></li><li class="chapter-item affix "><a href="when-to-use.html">When to Use</a></li><li class="chapter-item affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="ds-test-tutorial.html" class="active">ds-test tutorial</a></li><li class="chapter-item "><a href="equivalence-checking-tutorial.html">Equivalence checking tutorial</a></li><li class="chapter-item affix "><li class="part-title">Reference</li><li class="chapter-item "><a href="test.html">ds-test proving</a></li><li class="chapter-item "><a href="symbolic.html">Symbolic unit execution</a></li><li class="chapter-item "><a href="equivalence.html">Equivalence checking</a></li><li class="chapter-item "><a href="exec.html">Concrete execution</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">hevm</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ethereum/hevm" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="hhttps://github.com/ethereum/hevm/edit/main/src/ds-test-tutorial.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ds-test-tutorial"><a class="header" href="#ds-test-tutorial">ds-test Tutorial</a></h1>
<p>Test cases must be prepended with <code>prove_</code> and the testing contract must
inherit from <code>Test</code> from <a href="https://book.getfoundry.sh/forge/forge-std">Forge's standard test
library</a>. First, import Test:
<code>import {Test} from &quot;forge-std/Test.sol&quot;;</code> and then inherit from it via <code>... is Test</code>. This allows hevm to discover the test cases it needs to run. Like so:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from &quot;forge-std/Test.sol&quot;;
contract BadVaultTest is Test {
  function prove_mytest() {
  // environment setup, preconditions
  // call(s) to test
  // postcondition checks
  }
}
</code></pre>
<p>Once you have written such a test case, you need to compile with <code>forge build</code>
(see <a href="https://book.getfoundry.sh/forge/tests">forge documentation</a> for more
details) and then:</p>
<pre><code>$ hevm test
Checking 1 function(s) in contract src/badvault-test.sol:BadVault
[RUNNING] prove_mytest(uint256)
   [PASS] prove_mytest(uint256)
</code></pre>
<p>Here, hevm discovered the test case, and automatically checked it for
violations.</p>
<h2 id="setting-up-tests"><a class="header" href="#setting-up-tests">Setting Up Tests</a></h2>
<p>Tests usually need to set up the environment in a particular way, such
as contract address, storage, etc. This can be done via Cheat Codes that
can change the address of the caller, set block number, etc. See <a href="#supported-cheat-codes">Cheat
Codes</a> below for a range of cheat codes supported. Cheat Codes
are a standard method used by other tools, such as
<a href="https://book.getfoundry.sh/">Foundry</a>, so you should be able to re-use your
existing setup. An example setup could be:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from &quot;forge-std/Test.sol&quot;;
contract BadVaultTest is Test {
    MyVault vault;

    function setUp() public {
        // Set up environment
        vault = new BadVault();

        address user1 = address(1);
        vm.deal(user1, 1 ether);
        vm.prank(user1);
        vault.deposit{value: 1 ether}();

        address user2 = address(2);
        vm.deal(user2, 1 ether);
        vm.prank(user2);
        vault.deposit{value: 1 ether}();

        address attacker = address(42);
        vm.prank(attacker);
        // call(s) to test
        // postcondition checks
    }
}
</code></pre>
<p>The postconditions should check the state of the contract after the call(s) are
complete. In particular, it should check that the changes that the function applied
did not break any of the (invariants)[https://en.wikipedia.org/wiki/Invariant_(mathematics)]
of the contract, such as total number of tokens.</p>
<p>You can read more about testing and cheat codes in the (Foundry
Book)[https://book.getfoundry.sh/forge/cheatcodes] and you can see the
hevm-supported cheat codes <a href="#supported-cheat-codes">below</a>.</p>
<h2 id="understanding-counterexamples"><a class="header" href="#understanding-counterexamples">Understanding Counterexamples</a></h2>
<p>When hevm discovers a failure, it prints an example call how to trigger the failure. Let's see the following
simple solidity code:</p>
<pre><code>pragma solidity ^0.8.19;
import {Test} from &quot;forge-std/Test.sol&quot;;
contract MyContract is Test {
  mapping (address =&gt; uint) balances;
  function prove_single_fail(address recv, uint amt) public {
    require(balances[recv] &lt; 100);
    if (balances[recv] + amt &gt; 100) { revert(); }
    balances[recv] += amt;
    assert(balances[recv] &lt; 100);
  }
}
</code></pre>
<p>After compiling with <code>forge build</code>, when ran under hevm, we get:</p>
<pre><code>$ hevm test
Checking 1 function(s) in contract src/contract-fail.sol:MyContract
[RUNNING] prove_single_fail(address,uint256)
   [FAIL] prove_single_fail(address,uint256)
   Counterexample:
     result:   Revert: 0x4e487b710000000000000000000000000000000000000000000000000000000000000001
     calldata: prove_single_fail(0x0000000000000000000000000000000000000000,100)
</code></pre>
<p>Here, hevm provided us with a calldata, where the receiver happens to be the
zero address, and the value sent is exactly 100. This indeed is the boundary
condition where the function call fails. The function should have had a <code>&gt;=</code>
rather than a <code>&gt;</code> in the <code>if</code>. Notice that in this case, while hevm filled in
the <code>address</code> to give a complete call, the address itself is irrelevant,
although this is not explicitly mentioned.</p>
<h2 id="test-cases-that-must-always-revert"><a class="header" href="#test-cases-that-must-always-revert">Test Cases that Must Always Revert</a></h2>
<p>Hevm assumes that a test case should not always revert. If you have such a test
case, hevm will warn you and return a FAIL. For example this toy contract:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from &quot;forge-std/Test.sol&quot;;
contract MyContract is Test {
  uint256 cntr;
  function prove_allrevert(uint256 val) public {
      if(val &lt; 0) {
          unchecked { cntr = val; }
          revert();
      } else revert();
  }
}
</code></pre>
<p>When compiled with forge and then ran under hevm with <code>hevm test</code>, hevm returns:</p>
<pre><code>Checking 1 function(s) in contract src/contract-allrevert.sol:MyContract
[RUNNING] prove_allrevert(uint256)
   [FAIL] prove_allrevert(uint256)
   Reason:
     No reachable assertion violations, but all branches reverted
     Prefix this testname with `proveFail` if this is expected
</code></pre>
<p>This is sometimes undesirable. In these cases, prefix your contract with
<code>proveFail_</code> instead of <code>prove_</code>:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from &quot;forge-std/Test.sol&quot;;
contract MyContract is Test {
  uint256 cntr;
  function proveFail_allrevert_expected(uint256 val) public {
      if(val &lt; 0) {
          unchecked {
            cntr = val;
            cntr += 1;
          }
          revert();
      }
      else revert();
  }
}
</code></pre>
<p>When this is compiled with forge and then checked with hevm, it leads to:</p>
<pre><code>Checking 1 function(s) in contract src/contract-allrevert-expected.sol:MyContract
[RUNNING] proveFail_allrevert_expected(uint256)
   [PASS] proveFail_allrevert_expected(uint256)
</code></pre>
<p>Which is now the expected outcome.</p>
<h2 id="supported-cheat-codes"><a class="header" href="#supported-cheat-codes">Supported Cheat Codes</a></h2>
<p>Since hevm is an EVM implementation mainly dedicated to testing and
exploration, it features a set of &quot;cheat codes&quot; which can manipulate the
environment in which the execution is run. These can be accessed by calling
into a contract (typically called <code>Vm</code>) at address
<code>0x7109709ECfa91a80626fF3989D68f67F5b1DD12D</code>, which happens to be keccak(&quot;hevm cheat code&quot;),
implementing the following methods:</p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody>
<tr><td><code>function prank(address sender) public</code></td><td>Sets <code>msg.sender</code> to the specified <code>sender</code> for the next call.</td></tr>
<tr><td><code>function startPrank(address sender) public</code></td><td>Sets <code>msg.sender</code> to the specified <code>sender</code> until <code>stopPrank()</code> is called.</td></tr>
<tr><td><code>function stopPrank() public</code></td><td>Resets <code>msg.sender</code> to the default sender.</td></tr>
<tr><td><code>function deal(address usr, uint amt) public</code></td><td>Sets the eth balance of <code>usr</code> to <code>amt</code>. Note that if <code>usr</code> is a symbolic address, then it must be the address of a contract that has already been deployed. This restriction is in place to ensure soundness of our symbolic address encoding with respect to potential aliasing of symbolic addresses.</td></tr>
<tr><td><code>function store(address c, bytes32 loc, bytes32 val) public</code></td><td>Sets the slot <code>loc</code> of contract <code>c</code> to <code>val</code>.</td></tr>
<tr><td><code>function warp(uint x) public</code></td><td>Sets the block timestamp to <code>x</code>.</td></tr>
<tr><td><code>function roll(uint x) public</code></td><td>Sets the block number to <code>x</code>.</td></tr>
<tr><td><code>function assume(bool b) public</code></td><td>Add the condition <code>b</code> to the assumption base for the current branch. This functions almost identically to <code>require</code>. For most users, <code>require</code> is preferable. However, in case you wish to understand &amp; modify the internal IR of hevm, you may want to use <code>assume</code>.</td></tr>
<tr><td><code>function load(address c, bytes32 loc) public returns (bytes32 val)</code></td><td>Reads the slot <code>loc</code> of contract <code>c</code>.</td></tr>
<tr><td><code>function sign(uint sk, bytes32 digest) public returns (uint8 v, bytes32 r, bytes32 s)</code></td><td>Signs the <code>digest</code> using the private key <code>sk</code>. Note that signatures produced via <code>hevm.sign</code> will leak the private key.</td></tr>
<tr><td><code>function addr(uint sk) public returns (address addr)</code></td><td>Derives an ethereum address from the private key <code>sk</code>. Note that <code>hevm.addr(0)</code> will fail with <code>BadCheatCode</code> as <code>0</code> is an invalid ECDSA private key.</td></tr>
<tr><td><code>function ffi(string[] calldata) external returns (bytes memory)</code></td><td>Executes the arguments as a command in the system shell and returns stdout. Expects abi encoded values to be returned from the shell or an error will be thrown. Note that this cheatcode means test authors can execute arbitrary code on user machines as part of a call to <code>dapp test</code>, for this reason all calls to <code>ffi</code> will fail unless the <code>--ffi</code> flag is passed.</td></tr>
<tr><td><code>function createFork(string calldata urlOrAlias) external returns (uint256)</code></td><td>Creates a new fork with the given endpoint and the <em>latest</em> block and returns the identifier of the fork.</td></tr>
<tr><td><code>function selectFork(uint256 forkId) external</code></td><td>Takes a fork identifier created by <code>createFork</code> and sets the corresponding forked state as active.</td></tr>
<tr><td><code>function activeFork() external returns (uint256)</code></td><td>Returns the identifier of the current fork.</td></tr>
<tr><td><code>function label(address addr, string calldata label) external</code></td><td>Labels the address in traces</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="when-to-use.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="equivalence-checking-tutorial.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="when-to-use.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="equivalence-checking-tutorial.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="solidity.min.js"></script>


    </div>
    </body>
</html>
